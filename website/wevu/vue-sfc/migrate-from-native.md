---
title: 从原生小程序迁移到 Vue SFC
---

# 从原生小程序迁移到 Vue SFC

这章面向两类团队：

- 已有原生小程序项目，希望在不重写业务的前提下升级工程体验。
- 新项目想用 Vue SFC，但又不想丢掉小程序原生能力与性能特性。

## 为什么值得迁移

迁移到 `weapp-vite + wevu + Vue SFC`，核心收益不是“语法换皮”，而是工程效率的提升：

- 页面、组件、样式、配置聚合到单个 `.vue`，降低跨文件跳转成本。
- 保留小程序生态能力（分包、原生 API、组件生态），避免“框架兼容层”额外损耗。
- 统一 TypeScript 与模块化能力，减少“运行时才发现”的低级错误。
- 更容易沉淀可复用的组件、hooks、service 层，后续需求迭代更稳。

## 推荐迁移方法（低风险）

建议按“先稳住行为，再升级写法”的顺序推进：

1. 先接入 `weapp-vite`，保持页面行为不变，只替换构建链路。
2. 选一个中等复杂页面试点，优先迁移为 `.vue`，不立即做大规模重构。
3. 先做**机械迁移**：保证页面逻辑等价运行，再逐步抽离 composable。
4. 页面迁移稳定后，再迁移通用组件与业务组件。
5. 最后统一风格到 `<script setup lang="ts">` 与组合式 API。

这个顺序的好处是：每一步都可回滚，问题定位范围很小。

## 实战经验（建议直接照做）

### 1) 目录与路由先不动

迁移初期不要同时改页面路径、分包结构、业务路由。

- 页面路径稳定，便于快速比对迁移前后行为。
- 出问题时可以精准定位“是语法迁移问题，还是路由改动问题”。

### 2) 先保证“行为等价”

迁移第一目标不是“代码优雅”，而是“线上行为不变”。

- 先把原有输入、校验、提交、跳转流程跑通。
- 再分阶段做数据结构收敛、方法拆分、复用抽象。

### 3) 强制补齐数据兜底

原生项目里常见隐患：接口字段缺失时直接 `map/forEach`。

- 对数组字段做 `Array.isArray` 防御。
- 对字符串 JSON 参数做 `try/catch + fallback`。
- 对深层可选字段统一做空值保护。

这一步通常能直接减少一批线上 `TypeError`。

### 4) 页面与模板项目要保持对齐

如果你有 `apps/*` 与 `templates/*` 双份源码：

- 行为改动必须双端同步。
- 修复逻辑优先在 source 验证，再镜像到 template。

否则后续脚手架产物会出现“示例能跑、模板崩溃”的分叉问题。

### 5) 验证策略用“最小闭环”

每次迁移后优先执行最小验证：

- 单模板 build：`pnpm -C templates/<template-name> build`
- 单应用 build：`pnpm -C apps/<app-name> build`
- 必要时补一条 e2e 回归用例覆盖关键路径

避免一上来跑全量回归，影响迁移节奏。

## 迁移完成的验收清单

满足以下条件，说明你已经从“能跑”进入“可维护”：

- 核心页面已使用 Vue SFC，业务流程与原生版本一致。
- 常见数据空值场景有明确兜底，不再出现基础 `map/forEach` 崩溃。
- 公共组件与 service 层边界清晰，新增需求不需要跨层改动。
- 构建命令、调试方式、发布流程已固化到团队文档。

## 结论

从原生小程序迁移到 Vue SFC，最佳实践不是“一次性重写”，而是“分阶段替换 + 持续验收”。

先把风险降下来，再逐步提升代码形态，最终你会得到一个既保留小程序能力、又具备现代前端工程效率的代码库。
