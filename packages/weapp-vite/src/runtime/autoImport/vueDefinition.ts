import type { ComponentPropMap } from '../componentProps'
import type { ComponentMetadata } from './metadata'

function isValidIdentifierName(name: string) {
  return /^[A-Z_$][\w$]*$/i.test(name)
}

function formatPropertyKey(name: string) {
  if (isValidIdentifierName(name)) {
    return name
  }
  const escaped = name
    .replace(/\\/g, '\\\\')
    .replace(/'/g, '\\\'')
  return `'${escaped}'`
}

function formatPropsType(props?: ComponentPropMap) {
  if (!props || props.size === 0) {
    return 'Record<string, any>'
  }
  const entries = Array.from(props.entries()).sort((a, b) => a[0].localeCompare(b[0]))
  const lines: string[] = ['{']
  for (const [propName, type] of entries) {
    const key = formatPropertyKey(propName)
    lines.push(`  readonly ${key}?: ${type};`)
  }
  lines.push('}')
  return lines.join('\n')
}

export interface VueComponentsDefinitionOptions {
  /**
   * When enabled, `components.d.ts` will reference `weapp-vite/typed-components`
   * instead of duplicating the props types.
   */
  useTypedComponents?: boolean
}

function formatGlobalComponentEntry(name: string, metadata: ComponentMetadata) {
  const key = formatPropertyKey(name)
  const propsType = formatPropsType(metadata.types)
  if (propsType.includes('\n')) {
    const indented = propsType.split('\n').map((line, index) => {
      if (index === 0) {
        return line
      }
      return `      ${line}`
    }).join('\n')
    return `    ${key}: WeappComponent<${indented}>;`
  }
  return `    ${key}: WeappComponent<${propsType}>;`
}

function formatGlobalConstEntry(name: string, metadata: ComponentMetadata) {
  if (!isValidIdentifierName(name)) {
    return undefined
  }
  const propsType = formatPropsType(metadata.types)
  if (propsType.includes('\n')) {
    const indented = propsType.split('\n').map((line, index) => {
      if (index === 0) {
        return line
      }
      return `    ${line}`
    }).join('\n')
    return `  const ${name}: WeappComponent<${indented}>`
  }
  return `  const ${name}: WeappComponent<${propsType}>`
}

export function createVueComponentsDefinition(
  componentNames: string[],
  getMetadata: (name: string) => ComponentMetadata,
  options: VueComponentsDefinitionOptions = {},
) {
  const lines: string[] = [
    '/* eslint-disable */',
    '// @ts-nocheck',
    '// biome-ignore lint: disable',
    '// oxlint-disable',
    '// ------',
    '// Generated by weapp-vite autoImportComponents',
    'import type { DefineComponent } from \'vue\'',
    ...(options.useTypedComponents
      ? [
          'import type { ComponentProp } from \'weapp-vite/typed-components\'',
        ]
      : []),
    '',
    'export {}',
    '',
    'type WeappComponent<Props = Record<string, any>> = DefineComponent<Props, {}, any>',
    '',
    'declare module \'vue\' {',
    '  export interface GlobalComponents {',
  ]

  if (componentNames.length === 0) {
    lines.push('    [component: string]: WeappComponent;')
  }
  else {
    for (const name of componentNames) {
      if (options.useTypedComponents) {
        lines.push(`    ${formatPropertyKey(name)}: WeappComponent<ComponentProp<${JSON.stringify(name)}>>;`)
        continue
      }
      const metadata = getMetadata(name)
      lines.push(formatGlobalComponentEntry(name, metadata))
    }
    lines.push('    [component: string]: WeappComponent;')
  }

  lines.push('  }')
  lines.push('}')
  lines.push('')
  lines.push('// For TSX support')
  lines.push('declare global {')

  const globals = componentNames
    .map((name) => {
      if (options.useTypedComponents) {
        if (!isValidIdentifierName(name)) {
          return undefined
        }
        return `  const ${name}: WeappComponent<ComponentProp<${JSON.stringify(name)}>>`
      }
      const metadata = getMetadata(name)
      return formatGlobalConstEntry(name, metadata)
    })
    .filter((value): value is string => Boolean(value))

  if (globals.length === 0) {
    lines.push('}')
  }
  else {
    lines.push(...globals)
    lines.push('}')
  }

  lines.push('')
  return lines.join('\n')
}
