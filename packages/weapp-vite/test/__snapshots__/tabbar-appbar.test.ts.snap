// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`tabbar-appbar > dist > app.js 1`] = `
"const require_rolldown_runtime = require("./rolldown-runtime.js");
App({
	globalData: {},
	onLaunch() {}
});
"
`;

exports[`tabbar-appbar > dist > app.json 1`] = `
"{
  "pages": [
    "pages/index/index",
    "pages/index/vue",
    "pages/index/vue-setup"
  ],
  "window": {},
  "style": "v2",
  "componentFramework": "glass-easel",
  "sitemapLocation": "sitemap.json",
  "tabBar": {
    "custom": true
  },
  "appBar": {},
  "usingComponents": {
    "Test": "/components/Test"
  }
}"
`;

exports[`tabbar-appbar > dist > app.wxss 1`] = `"/*$vite$:1*/"`;

exports[`tabbar-appbar > dist > app-bar/index.js 1`] = `
"const require_rolldown_runtime = require("../rolldown-runtime.js");
Component({});
"
`;

exports[`tabbar-appbar > dist > app-bar/index.json 1`] = `
"{
  "component": true,
  "styleIsolation": "apply-shared",
  "usingComponents": {}
}"
`;

exports[`tabbar-appbar > dist > app-bar/index.wxml 1`] = `"<view>hello weapp-vite! from app-bar</view>"`;

exports[`tabbar-appbar > dist > app-bar/index.wxss 1`] = `
".ss {
  color: red;
}/*$vite$:1*/"
`;

exports[`tabbar-appbar > dist > async2.js 1`] = `
"const require_rolldown_runtime = require("./rolldown-runtime.js");
const async2 = "async2";
var async2_default = 2;
exports.async2 = async2;
exports.default = async2_default;
"
`;

exports[`tabbar-appbar > dist > common.js 1`] = `
"const require_rolldown_runtime = require("./rolldown-runtime.js");
var require_other = /* @__PURE__ */ require_rolldown_runtime.__commonJSMin(((exports, module) => {
	module.exports = { other: "other" };
}));
var resolvedPromise = Promise.resolve();
var jobQueue = /* @__PURE__ */ new Set();
var isFlushing = false;
function flushJobs() {
	isFlushing = true;
	try {
		jobQueue.forEach((job) => job());
	} finally {
		jobQueue.clear();
		isFlushing = false;
	}
}
function queueJob(job) {
	jobQueue.add(job);
	if (!isFlushing) resolvedPromise.then(flushJobs);
}
var targetMap = /* @__PURE__ */ new WeakMap();
var activeEffect = null;
var effectStack = [];
var batchDepth = 0;
var batchedEffects = /* @__PURE__ */ new Set();
var activeEffectScope;
function onScopeDispose(fn) {
	if (activeEffectScope?.active) activeEffectScope.cleanups.push(fn);
}
function recordEffectScope(effect$1) {
	if (activeEffectScope?.active) activeEffectScope.effects.push(effect$1);
}
function cleanupEffect(effect$1) {
	const { deps } = effect$1;
	for (let i = 0; i < deps.length; i++) deps[i].delete(effect$1);
	deps.length = 0;
}
function createReactiveEffect(fn, options = {}) {
	const effect$1 = function reactiveEffect() {
		if (!effect$1.active) return fn();
		if (effect$1._running) return fn();
		cleanupEffect(effect$1);
		try {
			effect$1._running = true;
			effectStack.push(effect$1);
			activeEffect = effect$1;
			return fn();
		} finally {
			effectStack.pop();
			activeEffect = effectStack[effectStack.length - 1] ?? null;
			effect$1._running = false;
		}
	};
	effect$1.deps = [];
	effect$1.scheduler = options.scheduler;
	effect$1.onStop = options.onStop;
	effect$1.active = true;
	effect$1._running = false;
	effect$1._fn = fn;
	return effect$1;
}
function effect(fn, options = {}) {
	const _effect = createReactiveEffect(fn, options);
	recordEffectScope(_effect);
	if (!options.lazy) _effect();
	return _effect;
}
function stop(runner) {
	if (!runner.active) return;
	runner.active = false;
	cleanupEffect(runner);
	runner.onStop?.();
}
function track(target, key) {
	if (!activeEffect) return;
	let depsMap = targetMap.get(target);
	if (!depsMap) {
		depsMap = /* @__PURE__ */ new Map();
		targetMap.set(target, depsMap);
	}
	let dep = depsMap.get(key);
	if (!dep) {
		dep = /* @__PURE__ */ new Set();
		depsMap.set(key, dep);
	}
	if (!dep.has(activeEffect)) {
		dep.add(activeEffect);
		activeEffect.deps.push(dep);
	}
}
function trigger(target, key) {
	const depsMap = targetMap.get(target);
	if (!depsMap) return;
	const effects = depsMap.get(key);
	if (!effects) return;
	const effectsToRun = /* @__PURE__ */ new Set();
	effects.forEach((ef) => {
		if (ef !== activeEffect) effectsToRun.add(ef);
	});
	effectsToRun.forEach(scheduleEffect);
}
function scheduleEffect(ef) {
	if (ef.scheduler) {
		ef.scheduler();
		return;
	}
	if (batchDepth > 0) {
		batchedEffects.add(ef);
		return;
	}
	ef();
}
function computed(getterOrOptions) {
	let getter;
	let setter;
	const onlyGetter = typeof getterOrOptions === "function";
	if (onlyGetter) {
		getter = getterOrOptions;
		setter = () => {
			throw new Error("Computed value is readonly");
		};
	} else {
		getter = getterOrOptions.get;
		setter = getterOrOptions.set;
	}
	let value;
	let dirty = true;
	let runner;
	const obj = {
		get value() {
			if (dirty) {
				value = runner();
				dirty = false;
			}
			track(obj, "value");
			return value;
		},
		set value(newValue) {
			setter(newValue);
		}
	};
	runner = effect(getter, {
		lazy: true,
		scheduler: () => {
			if (!dirty) {
				dirty = true;
				trigger(obj, "value");
			}
		}
	});
	return onlyGetter ? obj : obj;
}
var reactiveMap = /* @__PURE__ */ new WeakMap();
var rawMap = /* @__PURE__ */ new WeakMap();
var rawRootMap = /* @__PURE__ */ new WeakMap();
var ReactiveFlags = /* @__PURE__ */ function(ReactiveFlags$1) {
	ReactiveFlags$1["IS_REACTIVE"] = "__r_isReactive";
	ReactiveFlags$1["RAW"] = "__r_raw";
	ReactiveFlags$1["SKIP"] = "__r_skip";
	return ReactiveFlags$1;
}({});
function isObject$1(value) {
	return typeof value === "object" && value !== null;
}
var VERSION_KEY = Symbol("wevu.version");
var mutableHandlers = {
	get(target, key, receiver) {
		if (key === ReactiveFlags.IS_REACTIVE) return true;
		if (key === ReactiveFlags.RAW) return target;
		const res = Reflect.get(target, key, receiver);
		track(target, key);
		if (isObject$1(res)) {
			if (res[ReactiveFlags.SKIP]) return res;
			const child = res;
			const parentRoot = rawRootMap.get(target) ?? target;
			if (!rawRootMap.has(child)) rawRootMap.set(child, parentRoot);
			return reactive(res);
		}
		return res;
	},
	set(target, key, value, receiver) {
		const oldValue = Reflect.get(target, key, receiver);
		const result = Reflect.set(target, key, value, receiver);
		if (!Object.is(oldValue, value)) {
			trigger(target, key);
			trigger(target, VERSION_KEY);
			const root = rawRootMap.get(target);
			if (root && root !== target) trigger(root, VERSION_KEY);
		}
		return result;
	},
	deleteProperty(target, key) {
		const hadKey = Object.prototype.hasOwnProperty.call(target, key);
		const result = Reflect.deleteProperty(target, key);
		if (hadKey && result) {
			trigger(target, key);
			trigger(target, VERSION_KEY);
			const root = rawRootMap.get(target);
			if (root && root !== target) trigger(root, VERSION_KEY);
		}
		return result;
	},
	ownKeys(target) {
		track(target, Symbol.iterator);
		track(target, VERSION_KEY);
		return Reflect.ownKeys(target);
	}
};
function reactive(target) {
	if (!isObject$1(target)) return target;
	const existingProxy = reactiveMap.get(target);
	if (existingProxy) return existingProxy;
	if (target[ReactiveFlags.IS_REACTIVE]) return target;
	const proxy = new Proxy(target, mutableHandlers);
	reactiveMap.set(target, proxy);
	rawMap.set(proxy, target);
	if (!rawRootMap.has(target)) rawRootMap.set(target, target);
	return proxy;
}
function isReactive(value) {
	return Boolean(value && value[ReactiveFlags.IS_REACTIVE]);
}
function toRaw(observed) {
	return observed?.[ReactiveFlags.RAW] ?? observed;
}
function touchReactive(target) {
	track(toRaw(target), VERSION_KEY);
}
function isRef(value) {
	return Boolean(value && typeof value === "object" && "value" in value);
}
function unref(value) {
	return isRef(value) ? value.value : value;
}
function traverse(value, seen = /* @__PURE__ */ new Set()) {
	if (!isObject$1(value) || seen.has(value)) return value;
	seen.add(value);
	for (const key in value) traverse(value[key], seen);
	return value;
}
var __deepWatchStrategy = "version";
function watch(source, cb, options = {}) {
	let getter;
	if (typeof source === "function") getter = source;
	else if (isRef(source)) getter = () => source.value;
	else if (isReactive(source)) getter = () => source;
	else throw new Error("Invalid watch source");
	if (options.deep) {
		const baseGetter = getter;
		getter = () => {
			const val = baseGetter();
			if (__deepWatchStrategy === "version" && isReactive(val)) {
				touchReactive(val);
				return val;
			}
			return traverse(val);
		};
	}
	let cleanup;
	const onCleanup = (fn) => {
		cleanup = fn;
	};
	let oldValue;
	let runner;
	const job = () => {
		if (!runner.active) return;
		const newValue = runner();
		cleanup?.();
		cb(newValue, oldValue, onCleanup);
		oldValue = newValue;
	};
	runner = effect(() => getter(), {
		scheduler: () => queueJob(job),
		lazy: true
	});
	if (options.immediate) job();
	else oldValue = runner();
	const stopHandle = () => {
		cleanup?.();
		cleanup = void 0;
		stop(runner);
	};
	onScopeDispose(stopHandle);
	return stopHandle;
}
function capitalize(str) {
	if (!str) return "";
	return str.charAt(0).toUpperCase() + str.slice(1);
}
function toPathSegments(path) {
	if (!path) return [];
	return path.split(".").map((segment) => segment.trim()).filter(Boolean);
}
function setComputedValue$1(setters, key, value) {
	const setter = setters[key];
	if (!setter) throw new Error(\`Computed property "\${key}" is readonly\`);
	setter(value);
}
function setWithSegments(target, segments, value) {
	let current = target;
	for (let i = 0; i < segments.length - 1; i++) {
		const key = segments[i];
		if (current[key] == null || typeof current[key] !== "object") current[key] = {};
		current = current[key];
	}
	current[segments[segments.length - 1]] = value;
}
function setByPath(state, computedRefs, computedSetters, segments, value) {
	if (!segments.length) return;
	const [head, ...rest] = segments;
	if (!rest.length) {
		if (computedRefs[head]) setComputedValue$1(computedSetters, head, value);
		else state[head] = value;
		return;
	}
	if (computedRefs[head]) {
		setComputedValue$1(computedSetters, head, value);
		return;
	}
	if (state[head] == null || typeof state[head] !== "object") state[head] = {};
	setWithSegments(state[head], rest, value);
}
function getFromPath(target, segments) {
	return segments.reduce((acc, segment) => {
		if (acc == null) return acc;
		return acc[segment];
	}, target);
}
function defaultParser(event) {
	if (event == null) return event;
	if (typeof event === "object") {
		if ("detail" in event && event.detail && "value" in event.detail) return event.detail.value;
		if ("target" in event && event.target && "value" in event.target) return event.target.value;
	}
	return event;
}
function createBindModel(publicInstance, state, computedRefs, computedSetters) {
	const bindModel = (path, bindingOptions) => {
		const segments = toPathSegments(path);
		if (!segments.length) throw new Error("bindModel requires a non-empty path");
		const resolveValue = () => getFromPath(publicInstance, segments);
		const assignValue = (value) => {
			setByPath(state, computedRefs, computedSetters, segments, value);
		};
		const defaultOptions = {
			event: "input",
			valueProp: "value",
			parser: defaultParser,
			formatter: (value) => value,
			...bindingOptions
		};
		return {
			get value() {
				return resolveValue();
			},
			set value(nextValue) {
				assignValue(nextValue);
			},
			update(nextValue) {
				assignValue(nextValue);
			},
			model(modelOptions) {
				const merged = {
					...defaultOptions,
					...modelOptions
				};
				const handlerKey = \`on\${capitalize(merged.event)}\`;
				const payload = { [merged.valueProp]: merged.formatter(resolveValue()) };
				payload[handlerKey] = (event) => {
					assignValue(merged.parser(event));
				};
				return payload;
			}
		};
	};
	return bindModel;
}
function isPlainObject$1(value) {
	if (Object.prototype.toString.call(value) !== "[object Object]") return false;
	const proto = Object.getPrototypeOf(value);
	return proto === null || proto === Object.prototype;
}
function toPlain(value, seen = /* @__PURE__ */ new WeakMap()) {
	const unwrapped = unref(value);
	if (typeof unwrapped !== "object" || unwrapped === null) return unwrapped;
	const raw = isReactive(unwrapped) ? toRaw(unwrapped) : unwrapped;
	if (seen.has(raw)) return seen.get(raw);
	if (Array.isArray(raw)) {
		const arr = [];
		seen.set(raw, arr);
		raw.forEach((item, index) => {
			arr[index] = toPlain(item, seen);
		});
		return arr;
	}
	const output = {};
	seen.set(raw, output);
	Object.keys(raw).forEach((key) => {
		output[key] = toPlain(raw[key], seen);
	});
	return output;
}
function isDeepEqual(a, b) {
	if (Object.is(a, b)) return true;
	if (Array.isArray(a) && Array.isArray(b)) return isArrayEqual(a, b);
	if (isPlainObject$1(a) && isPlainObject$1(b)) return isPlainObjectEqual(a, b);
	return false;
}
function isArrayEqual(a, b) {
	if (a.length !== b.length) return false;
	for (let i = 0; i < a.length; i++) if (!isDeepEqual(a[i], b[i])) return false;
	return true;
}
function isPlainObjectEqual(a, b) {
	const aKeys = Object.keys(a);
	const bKeys = Object.keys(b);
	if (aKeys.length !== bKeys.length) return false;
	for (const key of aKeys) {
		if (!Object.prototype.hasOwnProperty.call(b, key)) return false;
		if (!isDeepEqual(a[key], b[key])) return false;
	}
	return true;
}
function normalizeSetDataValue(value) {
	return value === void 0 ? null : value;
}
function assignNestedDiff(prev, next, path, output) {
	if (isDeepEqual(prev, next)) return;
	if (isPlainObject$1(prev) && isPlainObject$1(next)) {
		new Set([...Object.keys(prev), ...Object.keys(next)]).forEach((key) => {
			if (!Object.prototype.hasOwnProperty.call(next, key)) {
				output[\`\${path}.\${key}\`] = null;
				return;
			}
			assignNestedDiff(prev[key], next[key], \`\${path}.\${key}\`, output);
		});
		return;
	}
	if (Array.isArray(prev) && Array.isArray(next)) {
		if (!isArrayEqual(prev, next)) output[path] = normalizeSetDataValue(next);
		return;
	}
	output[path] = normalizeSetDataValue(next);
}
function diffSnapshots(prev, next) {
	const diff = {};
	new Set([...Object.keys(prev), ...Object.keys(next)]).forEach((key) => {
		if (!Object.prototype.hasOwnProperty.call(next, key)) {
			diff[key] = null;
			return;
		}
		assignNestedDiff(prev[key], next[key], key, diff);
	});
	return diff;
}
var __currentInstance;
var __currentSetupContext;
function setCurrentInstance(inst) {}
function setCurrentSetupContext(ctx) {}
function callHookList(target, name, args = []) {
	const hooks = target.__wevuHooks;
	if (!hooks) return;
	const list = hooks[name];
	if (!list) return;
	const ctx = target.__wevu?.proxy ?? target;
	if (Array.isArray(list)) for (const fn of list) try {
		fn.apply(ctx, args);
	} catch {}
	else if (typeof list === "function") try {
		list.apply(ctx, args);
	} catch {}
}
function callHookReturn(target, name, args = []) {
	const hooks = target.__wevuHooks;
	if (!hooks) return;
	const entry = hooks[name];
	if (!entry) return;
	const ctx = target.__wevu?.proxy ?? target;
	if (typeof entry === "function") try {
		return entry.apply(ctx, args);
	} catch {
		return;
	}
	if (Array.isArray(entry)) {
		let out;
		for (const fn of entry) try {
			out = fn.apply(ctx, args);
		} catch {}
		return out;
	}
}
function runInlineExpression(ctx, expr, event) {
	const handlerName = typeof expr === "string" ? expr : void 0;
	if (!handlerName) return;
	const argsRaw = (event?.currentTarget)?.dataset?.wvArgs ?? (event?.target)?.dataset?.wvArgs;
	let args = [];
	if (typeof argsRaw === "string") try {
		args = JSON.parse(argsRaw);
	} catch {
		args = [];
	}
	const resolvedArgs = args.map((item) => item === "$event" ? event : item);
	const handler = ctx?.[handlerName];
	if (typeof handler === "function") return handler.apply(ctx, resolvedArgs);
}
function runSetupFunction(setup, props, context) {
	if (typeof setup !== "function") return;
	const runtimeContext = context?.runtime ?? {
		methods: Object.create(null),
		state: {},
		proxy: {},
		watch: () => () => {},
		bindModel: () => {}
	};
	if (context) context.runtime = runtimeContext;
	const finalContext = {
		...context ?? {},
		runtime: runtimeContext
	};
	return setup.length >= 2 ? setup(props, finalContext) : setup(finalContext);
}
function normalizeWatchDescriptor(descriptor, runtime, instance) {
	if (typeof descriptor === "function") return {
		handler: descriptor.bind(runtime.proxy),
		options: {}
	};
	if (typeof descriptor === "string") {
		const method = runtime.methods?.[descriptor] ?? instance[descriptor];
		if (typeof method === "function") return {
			handler: method.bind(runtime.proxy),
			options: {}
		};
		return;
	}
	if (!descriptor || typeof descriptor !== "object") return;
	const base = normalizeWatchDescriptor(descriptor.handler, runtime, instance);
	if (!base) return;
	const options = { ...base.options };
	if (descriptor.immediate !== void 0) options.immediate = descriptor.immediate;
	if (descriptor.deep !== void 0) options.deep = descriptor.deep;
	return {
		handler: base.handler,
		options
	};
}
function createPathGetter(target, path) {
	const segments = path.split(".").map((segment) => segment.trim()).filter(Boolean);
	if (!segments.length) return () => target;
	return () => {
		let current = target;
		for (const segment of segments) {
			if (current == null) return current;
			current = current[segment];
		}
		return current;
	};
}
function registerWatches(runtime, watchMap, instance) {
	const stops = [];
	const proxy = runtime.proxy;
	for (const [expression, descriptor] of Object.entries(watchMap)) {
		const normalized = normalizeWatchDescriptor(descriptor, runtime, instance);
		if (!normalized) continue;
		const getter = createPathGetter(proxy, expression);
		const stop$1 = runtime.watch(getter, normalized.handler, normalized.options);
		stops.push(stop$1);
	}
	return stops;
}
function mountRuntimeInstance(target, runtimeApp, watchMap, setup, options) {
	if (target.__wevu) return target.__wevu;
	const createDeferredAdapter = (instance) => {
		let pending;
		let enabled = false;
		const adapter$1 = { setData(payload) {
			if (!enabled) {
				pending = {
					...pending ?? {},
					...payload
				};
				return;
			}
			if (typeof instance.setData === "function") return instance.setData(payload);
		} };
		adapter$1.__wevu_enableSetData = () => {
			enabled = true;
			if (pending && Object.keys(pending).length && typeof instance.setData === "function") {
				const payload = pending;
				pending = void 0;
				instance.setData(payload);
			}
		};
		return adapter$1;
	};
	const adapter = options?.deferSetData ? createDeferredAdapter(target) : { setData(payload) {
		if (typeof target.setData === "function") return target.setData(payload);
	} };
	const runtime = runtimeApp.mount({ ...adapter });
	const runtimeProxy = runtime?.proxy ?? {};
	const runtimeState = runtime?.state ?? {};
	if (!runtime?.methods) try {
		runtime.methods = Object.create(null);
	} catch {}
	const runtimeMethods = runtime?.methods ?? Object.create(null);
	const runtimeWatch = runtime?.watch ?? (() => () => {});
	const runtimeBindModel = runtime?.bindModel ?? (() => {});
	const runtimeWithDefaults = {
		...runtime ?? {},
		state: runtimeState,
		proxy: runtimeProxy,
		methods: runtimeMethods,
		watch: runtimeWatch,
		bindModel: runtimeBindModel
	};
	Object.defineProperty(target, "$wevu", {
		value: runtimeWithDefaults,
		configurable: true,
		enumerable: false,
		writable: false
	});
	target.__wevu = runtimeWithDefaults;
	if (watchMap) {
		const stops = registerWatches(runtimeWithDefaults, watchMap, target);
		if (stops.length) target.__wevuWatchStops = stops;
	}
	if (setup) {
		const props = target.properties || {};
		const context = {
			props,
			runtime: runtimeWithDefaults,
			state: runtimeState,
			proxy: runtimeProxy,
			bindModel: runtimeBindModel.bind(runtimeWithDefaults),
			watch: runtimeWatch.bind(runtimeWithDefaults),
			instance: target,
			emit: (event, detail, options$1) => {
				if (typeof target.triggerEvent === "function") target.triggerEvent(event, detail, options$1);
			},
			expose: (exposed) => {
				target.__wevuExposed = exposed;
			},
			attrs: {},
			slots: Object.create(null)
		};
		setCurrentInstance(target);
		setCurrentSetupContext(context);
		try {
			const result = runSetupFunction(setup, props, context);
			if (result && typeof result === "object") Object.keys(result).forEach((key) => {
				const val = result[key];
				if (typeof val === "function") runtime.methods[key] = (...args) => val.apply(runtime.proxy, args);
				else runtime.state[key] = val;
			});
		} finally {
			setCurrentSetupContext(void 0);
			setCurrentInstance(void 0);
		}
	}
	try {
		const methods = runtime.methods;
		for (const name of Object.keys(methods)) if (typeof target[name] !== "function") target[name] = function bridged(...args) {
			const bound = (this.$wevu?.methods)?.[name];
			if (typeof bound === "function") return bound.apply(this.$wevu.proxy, args);
		};
	} catch {}
	return runtime;
}
function enableDeferredSetData(target) {
	const adapter = target.__wevu?.adapter;
	if (adapter && typeof adapter.__wevu_enableSetData === "function") adapter.__wevu_enableSetData();
}
function teardownRuntimeInstance(target) {
	const runtime = target.__wevu;
	if (runtime && target.__wevuHooks) callHookList(target, "onUnload", []);
	if (target.__wevuHooks) target.__wevuHooks = void 0;
	const stops = target.__wevuWatchStops;
	if (Array.isArray(stops)) for (const stop$1 of stops) try {
		stop$1();
	} catch {}
	target.__wevuWatchStops = void 0;
	if (runtime) runtime.unmount();
	delete target.__wevu;
	if ("$wevu" in target) delete target.$wevu;
}
function registerApp(runtimeApp, methods, watch$1, setup, mpOptions) {
	if (typeof App !== "function") throw new TypeError("createApp requires the global App constructor to be available");
	const methodNames = Object.keys(methods ?? {});
	const appOptions = { ...mpOptions };
	appOptions.globalData = appOptions.globalData ?? {};
	if (!appOptions.__weapp_vite_inline) appOptions.__weapp_vite_inline = function __weapp_vite_inline(event) {
		const expr = event?.currentTarget?.dataset?.wvHandler ?? event?.target?.dataset?.wvHandler;
		return runInlineExpression(this.__wevu?.proxy ?? this, expr, event);
	};
	const userOnLaunch = appOptions.onLaunch;
	appOptions.onLaunch = function onLaunch(...args) {
		mountRuntimeInstance(this, runtimeApp, watch$1, setup);
		callHookList(this, "onAppLaunch", args);
		if (typeof userOnLaunch === "function") userOnLaunch.apply(this, args);
	};
	const userOnShow = appOptions.onShow;
	appOptions.onShow = function onShow$1(...args) {
		callHookList(this, "onAppShow", args);
		if (typeof userOnShow === "function") userOnShow.apply(this, args);
	};
	const userOnHide = appOptions.onHide;
	appOptions.onHide = function onHide$1(...args) {
		callHookList(this, "onAppHide", args);
		if (typeof userOnHide === "function") userOnHide.apply(this, args);
	};
	const userOnError = appOptions.onError;
	appOptions.onError = function onError$1(...args) {
		callHookList(this, "onAppError", args);
		if (typeof userOnError === "function") userOnError.apply(this, args);
	};
	for (const methodName of methodNames) {
		const userMethod = appOptions[methodName];
		appOptions[methodName] = function runtimeMethod(...args) {
			const runtime = this.__wevu;
			let result;
			const bound = runtime?.methods?.[methodName];
			if (bound) result = bound.apply(runtime.proxy, args);
			if (typeof userMethod === "function") return userMethod.apply(this, args);
			return result;
		};
	}
	App(appOptions);
}
function registerComponent(runtimeApp, methods, watch$1, setup, mpOptions) {
	const { methods: userMethods = {}, lifetimes: userLifetimes = {}, pageLifetimes: userPageLifetimes = {}, options: userOptions = {}, ...rest } = mpOptions;
	const userOnLoad = rest.onLoad;
	const userOnUnload = rest.onUnload;
	const userOnShow = rest.onShow;
	const userOnHide = rest.onHide;
	const userOnReady = rest.onReady;
	const userOnSaveExitState = rest.onSaveExitState;
	const userOnPullDownRefresh = rest.onPullDownRefresh;
	const userOnReachBottom = rest.onReachBottom;
	const userOnPageScroll = rest.onPageScroll;
	const userOnRouteDone = rest.onRouteDone;
	const userOnTabItemTap = rest.onTabItemTap;
	const userOnResize = rest.onResize;
	const userOnShareAppMessage = rest.onShareAppMessage;
	const userOnShareTimeline = rest.onShareTimeline;
	const userOnAddToFavorites = rest.onAddToFavorites;
	const features = rest.features ?? {};
	const restOptions = { ...rest };
	const legacyCreated = restOptions.created;
	delete restOptions.features;
	delete restOptions.created;
	delete restOptions.onLoad;
	delete restOptions.onUnload;
	delete restOptions.onShow;
	delete restOptions.onHide;
	delete restOptions.onReady;
	const enableOnPullDownRefresh = typeof userOnPullDownRefresh === "function" || Boolean(features.enableOnPullDownRefresh);
	const enableOnReachBottom = typeof userOnReachBottom === "function" || Boolean(features.enableOnReachBottom);
	const enableOnPageScroll = typeof userOnPageScroll === "function" || Boolean(features.enableOnPageScroll);
	const enableOnRouteDone = typeof userOnRouteDone === "function" || Boolean(features.enableOnRouteDone);
	const enableOnTabItemTap = typeof userOnTabItemTap === "function" || Boolean(features.enableOnTabItemTap);
	const enableOnResize = typeof userOnResize === "function" || Boolean(features.enableOnResize);
	const enableOnShareAppMessage = typeof userOnShareAppMessage === "function" || Boolean(features.enableOnShareAppMessage);
	const enableOnShareTimeline = typeof userOnShareTimeline === "function" || Boolean(features.enableOnShareTimeline);
	const enableOnAddToFavorites = typeof userOnAddToFavorites === "function" || Boolean(features.enableOnAddToFavorites);
	const enableOnSaveExitState = typeof userOnSaveExitState === "function" || Boolean(features.enableOnSaveExitState);
	const fallbackNoop = () => {};
	const fallbackShareContent = () => ({});
	const fallbackTimelineContent = () => ({});
	const effectiveOnSaveExitState = typeof userOnSaveExitState === "function" ? userOnSaveExitState : (() => ({ data: void 0 }));
	const effectiveOnPullDownRefresh = typeof userOnPullDownRefresh === "function" ? userOnPullDownRefresh : fallbackNoop;
	const effectiveOnReachBottom = typeof userOnReachBottom === "function" ? userOnReachBottom : fallbackNoop;
	const effectiveOnPageScroll = typeof userOnPageScroll === "function" ? userOnPageScroll : fallbackNoop;
	const effectiveOnRouteDone = typeof userOnRouteDone === "function" ? userOnRouteDone : fallbackNoop;
	const effectiveOnTabItemTap = typeof userOnTabItemTap === "function" ? userOnTabItemTap : fallbackNoop;
	const effectiveOnResize = typeof userOnResize === "function" ? userOnResize : fallbackNoop;
	const effectiveOnShareAppMessage = typeof userOnShareAppMessage === "function" ? userOnShareAppMessage : fallbackShareContent;
	const effectiveOnShareTimeline = typeof userOnShareTimeline === "function" ? userOnShareTimeline : fallbackTimelineContent;
	const effectiveOnAddToFavorites = typeof userOnAddToFavorites === "function" ? userOnAddToFavorites : (() => ({}));
	const hasHook = (target, name) => {
		const hooks = target.__wevuHooks;
		if (!hooks) return false;
		const entry = hooks[name];
		if (!entry) return false;
		if (Array.isArray(entry)) return entry.length > 0;
		return typeof entry === "function";
	};
	{
		const userExport = restOptions.export;
		restOptions.export = function __wevu_export() {
			const exposed = this.__wevuExposed ?? {};
			const base = typeof userExport === "function" ? userExport.call(this) : {};
			if (base && typeof base === "object" && !Array.isArray(base)) return {
				...exposed,
				...base
			};
			return base ?? exposed;
		};
	}
	const finalOptions = {
		multipleSlots: userOptions.multipleSlots ?? true,
		...userOptions
	};
	const finalMethods = { ...userMethods };
	if (!finalMethods.__weapp_vite_inline) finalMethods.__weapp_vite_inline = function __weapp_vite_inline(event) {
		const expr = event?.currentTarget?.dataset?.wvHandler ?? event?.target?.dataset?.wvHandler;
		return runInlineExpression(this.__wevu?.proxy ?? this, expr, event);
	};
	const methodNames = Object.keys(methods ?? {});
	for (const methodName of methodNames) {
		const userMethod = finalMethods[methodName];
		finalMethods[methodName] = function componentMethod(...args) {
			const runtime = this.__wevu;
			let result;
			const bound = runtime?.methods?.[methodName];
			if (bound) result = bound.apply(runtime.proxy, args);
			if (typeof userMethod === "function") return userMethod.apply(this, args);
			return result;
		};
	}
	const pageLifecycleHooks = {
		onLoad(...args) {
			mountRuntimeInstance(this, runtimeApp, watch$1, setup);
			enableDeferredSetData(this);
			callHookList(this, "onLoad", args);
			if (typeof userOnLoad === "function") return userOnLoad.apply(this, args);
		},
		onUnload(...args) {
			teardownRuntimeInstance(this);
			if (typeof userOnUnload === "function") return userOnUnload.apply(this, args);
		},
		onShow(...args) {
			callHookList(this, "onShow", args);
			if (typeof userOnShow === "function") return userOnShow.apply(this, args);
		},
		onHide(...args) {
			callHookList(this, "onHide", args);
			if (typeof userOnHide === "function") return userOnHide.apply(this, args);
		},
		onReady(...args) {
			if (!this.__wevuReadyCalled) {
				this.__wevuReadyCalled = true;
				callHookList(this, "onReady", args);
			}
			if (typeof userOnReady === "function") return userOnReady.apply(this, args);
		}
	};
	if (enableOnSaveExitState) pageLifecycleHooks.onSaveExitState = function onSaveExitState$1(...args) {
		const ret = callHookReturn(this, "onSaveExitState", args);
		if (ret !== void 0) return ret;
		return effectiveOnSaveExitState.apply(this, args);
	};
	if (enableOnPullDownRefresh) pageLifecycleHooks.onPullDownRefresh = function onPullDownRefresh$1(...args) {
		callHookList(this, "onPullDownRefresh", args);
		if (!hasHook(this, "onPullDownRefresh")) return effectiveOnPullDownRefresh.apply(this, args);
	};
	if (enableOnReachBottom) pageLifecycleHooks.onReachBottom = function onReachBottom$1(...args) {
		callHookList(this, "onReachBottom", args);
		if (!hasHook(this, "onReachBottom")) return effectiveOnReachBottom.apply(this, args);
	};
	if (enableOnPageScroll) pageLifecycleHooks.onPageScroll = function onPageScroll$1(...args) {
		callHookList(this, "onPageScroll", args);
		if (!hasHook(this, "onPageScroll")) return effectiveOnPageScroll.apply(this, args);
	};
	if (enableOnRouteDone) pageLifecycleHooks.onRouteDone = function onRouteDone$1(...args) {
		callHookList(this, "onRouteDone", args);
		if (!hasHook(this, "onRouteDone")) return effectiveOnRouteDone.apply(this, args);
	};
	if (enableOnTabItemTap) pageLifecycleHooks.onTabItemTap = function onTabItemTap$1(...args) {
		callHookList(this, "onTabItemTap", args);
		if (!hasHook(this, "onTabItemTap")) return effectiveOnTabItemTap.apply(this, args);
	};
	if (enableOnResize) pageLifecycleHooks.onResize = function onResize$1(...args) {
		callHookList(this, "onResize", args);
		if (!hasHook(this, "onResize")) return effectiveOnResize.apply(this, args);
	};
	if (enableOnShareAppMessage) pageLifecycleHooks.onShareAppMessage = function onShareAppMessage$1(...args) {
		const ret = callHookReturn(this, "onShareAppMessage", args);
		if (ret !== void 0) return ret;
		return effectiveOnShareAppMessage.apply(this, args);
	};
	if (enableOnShareTimeline) pageLifecycleHooks.onShareTimeline = function onShareTimeline$1(...args) {
		const ret = callHookReturn(this, "onShareTimeline", args);
		if (ret !== void 0) return ret;
		return effectiveOnShareTimeline.apply(this, args);
	};
	if (enableOnAddToFavorites) pageLifecycleHooks.onAddToFavorites = function onAddToFavorites$1(...args) {
		const ret = callHookReturn(this, "onAddToFavorites", args);
		if (ret !== void 0) return ret;
		return effectiveOnAddToFavorites.apply(this, args);
	};
	Component({
		...restOptions,
		...pageLifecycleHooks,
		lifetimes: {
			...userLifetimes,
			created: function created(...args) {
				mountRuntimeInstance(this, runtimeApp, watch$1, setup, { deferSetData: true });
				if (typeof legacyCreated === "function") legacyCreated.apply(this, args);
				if (typeof userLifetimes.created === "function") userLifetimes.created.apply(this, args);
			},
			moved: function moved(...args) {
				callHookList(this, "onMoved", args);
				if (typeof userLifetimes.moved === "function") userLifetimes.moved.apply(this, args);
			},
			attached: function attached(...args) {
				mountRuntimeInstance(this, runtimeApp, watch$1, setup);
				enableDeferredSetData(this);
				if (typeof userLifetimes.attached === "function") userLifetimes.attached.apply(this, args);
			},
			ready: function ready(...args) {
				if (!this.__wevuReadyCalled) {
					this.__wevuReadyCalled = true;
					callHookList(this, "onReady", args);
				}
				if (typeof userLifetimes.ready === "function") userLifetimes.ready.apply(this, args);
			},
			detached: function detached(...args) {
				teardownRuntimeInstance(this);
				if (typeof userLifetimes.detached === "function") userLifetimes.detached.apply(this, args);
			},
			error: function error(...args) {
				callHookList(this, "onError", args);
				if (typeof userLifetimes.error === "function") userLifetimes.error.apply(this, args);
			}
		},
		pageLifetimes: {
			...userPageLifetimes,
			show: function show(...args) {
				callHookList(this, "onShow", args);
				if (typeof userPageLifetimes.show === "function") userPageLifetimes.show.apply(this, args);
			},
			hide: function hide(...args) {
				callHookList(this, "onHide", args);
				if (typeof userPageLifetimes.hide === "function") userPageLifetimes.hide.apply(this, args);
			},
			resize: function resize(...args) {
				callHookList(this, "onResize", args);
				if (typeof userPageLifetimes.resize === "function") userPageLifetimes.resize.apply(this, args);
			}
		},
		methods: finalMethods,
		options: finalOptions
	});
}
function createApp(options) {
	const { data, computed: computedOptions, methods, watch: appWatch, setup: appSetup, ...mpOptions } = options;
	const resolvedMethods = methods ?? {};
	const resolvedComputed = computedOptions ?? {};
	const installedPlugins = /* @__PURE__ */ new Set();
	const appConfig = { globalProperties: {} };
	const runtimeApp = {
		mount(adapter) {
			const state = reactive((data ?? (() => ({})))());
			const computedDefs = resolvedComputed;
			const methodDefs = resolvedMethods;
			const computedRefs = Object.create(null);
			const computedSetters = Object.create(null);
			const boundMethods = {};
			let mounted = true;
			let latestSnapshot = {};
			const stopHandles = [];
			const computedProxy = new Proxy({}, {
				get(_target, key) {
					if (typeof key === "string" && computedRefs[key]) return computedRefs[key].value;
				},
				has(_target, key) {
					return typeof key === "string" && Boolean(computedRefs[key]);
				},
				ownKeys() {
					return Object.keys(computedRefs);
				},
				getOwnPropertyDescriptor(_target, key) {
					if (typeof key === "string" && computedRefs[key]) return {
						configurable: true,
						enumerable: true,
						value: computedRefs[key].value
					};
				}
			});
			const publicInstance = new Proxy(state, {
				get(target, key, receiver) {
					if (typeof key === "string") {
						if (key === "$state") return state;
						if (key === "$computed") return computedProxy;
						if (Object.prototype.hasOwnProperty.call(boundMethods, key)) return boundMethods[key];
						if (computedRefs[key]) return computedRefs[key].value;
						if (Object.prototype.hasOwnProperty.call(appConfig.globalProperties, key)) return appConfig.globalProperties[key];
					}
					return Reflect.get(target, key, receiver);
				},
				set(target, key, value, receiver) {
					if (typeof key === "string" && computedRefs[key]) {
						setComputedValue(computedSetters, key, value);
						return true;
					}
					return Reflect.set(target, key, value, receiver);
				},
				has(target, key) {
					if (typeof key === "string" && (computedRefs[key] || Object.prototype.hasOwnProperty.call(boundMethods, key))) return true;
					return Reflect.has(target, key);
				},
				ownKeys(target) {
					const keys = /* @__PURE__ */ new Set();
					Reflect.ownKeys(target).forEach((key) => {
						keys.add(key);
					});
					Object.keys(boundMethods).forEach((key) => keys.add(key));
					Object.keys(computedRefs).forEach((key) => keys.add(key));
					return Array.from(keys);
				},
				getOwnPropertyDescriptor(target, key) {
					if (Reflect.has(target, key)) return Object.getOwnPropertyDescriptor(target, key);
					if (typeof key === "string") {
						if (computedRefs[key]) return {
							configurable: true,
							enumerable: true,
							get() {
								return computedRefs[key].value;
							},
							set(value) {
								setComputedValue(computedSetters, key, value);
							}
						};
						if (Object.prototype.hasOwnProperty.call(boundMethods, key)) return {
							configurable: true,
							enumerable: false,
							value: boundMethods[key]
						};
					}
				}
			});
			Object.keys(methodDefs).forEach((key) => {
				const handler = methodDefs[key];
				if (typeof handler === "function") boundMethods[key] = (...args) => handler.apply(publicInstance, args);
			});
			Object.keys(computedDefs).forEach((key) => {
				const definition = computedDefs[key];
				if (typeof definition === "function") computedRefs[key] = computed(() => definition.call(publicInstance));
				else {
					const getter = definition.get?.bind(publicInstance);
					if (!getter) throw new Error(\`Computed property "\${key}" requires a getter\`);
					const setter = definition.set?.bind(publicInstance);
					if (setter) {
						computedSetters[key] = setter;
						computedRefs[key] = computed({
							get: getter,
							set: setter
						});
					} else computedRefs[key] = computed(getter);
				}
			});
			const currentAdapter = adapter ?? { setData: () => {} };
			const collectSnapshot = () => {
				const plain = toPlain(state);
				Object.keys(computedRefs).forEach((key) => {
					plain[key] = toPlain(computedRefs[key].value);
				});
				return plain;
			};
			const job = () => {
				if (!mounted) return;
				tracker();
				const snapshot = collectSnapshot();
				const diff = diffSnapshots(latestSnapshot, snapshot);
				latestSnapshot = snapshot;
				if (!Object.keys(diff).length) return;
				if (typeof currentAdapter.setData === "function") {
					const result = currentAdapter.setData(diff);
					if (result && typeof result.then === "function") result.catch(() => {});
				}
			};
			let tracker;
			tracker = effect(() => {
				touchReactive(state);
				Object.keys(state).forEach((key) => {
					const v = state[key];
					if (isRef(v)) v.value;
				});
				Object.keys(computedRefs).forEach((key) => computedRefs[key].value);
			}, {
				lazy: true,
				scheduler: () => queueJob(job)
			});
			job();
			stopHandles.push(() => stop(tracker));
			function registerWatch(source, cb, watchOptions) {
				const stopHandle = watch(source, (value, oldValue) => cb(value, oldValue), watchOptions);
				stopHandles.push(stopHandle);
				return () => {
					stopHandle();
					const index = stopHandles.indexOf(stopHandle);
					if (index >= 0) stopHandles.splice(index, 1);
				};
			}
			const bindModel = createBindModel(publicInstance, state, computedRefs, computedSetters);
			const unmount = () => {
				if (!mounted) return;
				mounted = false;
				stopHandles.forEach((handle) => {
					try {
						handle();
					} catch {}
				});
				stopHandles.length = 0;
			};
			return {
				get state() {
					return state;
				},
				get proxy() {
					return publicInstance;
				},
				get methods() {
					return boundMethods;
				},
				get computed() {
					return computedProxy;
				},
				get adapter() {
					return currentAdapter;
				},
				bindModel,
				watch: registerWatch,
				snapshot: () => ({ ...latestSnapshot }),
				unmount
			};
		},
		use(plugin, ...options$1) {
			if (!plugin || installedPlugins.has(plugin)) return runtimeApp;
			installedPlugins.add(plugin);
			if (typeof plugin === "function") plugin(runtimeApp, ...options$1);
			else if (typeof plugin.install === "function") plugin.install(runtimeApp, ...options$1);
			else throw new TypeError("A plugin must be a function or an object with an install method");
			return runtimeApp;
		},
		config: appConfig
	};
	if (typeof globalThis.App === "function") registerApp(runtimeApp, methods ?? {}, appWatch, appSetup, mpOptions);
	return runtimeApp;
}
function setComputedValue(setters, key, value) {
	const setter = setters[key];
	if (!setter) throw new Error(\`Computed property "\${key}" is readonly\`);
	setter(value);
}
function defineComponent(options) {
	const { data, computed: computed$1, methods, watch: watch$1, setup, props, ...mpOptions } = options;
	const runtimeApp = createApp({
		data,
		computed: computed$1,
		methods
	});
	const setupWrapper = (ctx) => {
		const result = runSetupFunction(setup, ctx?.props ?? {}, ctx);
		if (result) applySetupResult(ctx.runtime, ctx.instance, result);
	};
	const mpOptionsWithProps = normalizeProps(mpOptions, props);
	const componentOptions = {
		data,
		computed: computed$1,
		methods,
		watch: watch$1,
		setup: setupWrapper,
		mpOptions: mpOptionsWithProps
	};
	registerComponent(runtimeApp, methods ?? {}, watch$1, setupWrapper, mpOptionsWithProps);
	return {
		__wevu_runtime: runtimeApp,
		__wevu_options: componentOptions
	};
}
function applySetupResult(runtime, _target, result) {
	const methods = runtime?.methods ?? Object.create(null);
	const state = runtime?.state ?? Object.create(null);
	const rawState = isReactive(state) ? toRaw(state) : state;
	if (runtime && !runtime.methods) try {
		runtime.methods = methods;
	} catch {}
	if (runtime && !runtime.state) try {
		runtime.state = state;
	} catch {}
	Object.keys(result).forEach((key) => {
		const val = result[key];
		if (typeof val === "function") methods[key] = (...args) => val.apply(runtime?.proxy ?? runtime, args);
		else if (val === _target || !shouldExposeInSnapshot(val)) try {
			Object.defineProperty(rawState, key, {
				value: val,
				configurable: true,
				enumerable: false,
				writable: true
			});
		} catch {
			state[key] = val;
		}
		else state[key] = val;
	});
	if (runtime) {
		runtime.methods = runtime.methods ?? methods;
		runtime.state = runtime.state ?? state;
	}
}
function isPlainObject(value) {
	if (Object.prototype.toString.call(value) !== "[object Object]") return false;
	const proto = Object.getPrototypeOf(value);
	return proto === null || proto === Object.prototype;
}
function shouldExposeInSnapshot(value) {
	if (value == null) return true;
	if (typeof value !== "object") return true;
	if (isRef(value) || isReactive(value)) return true;
	if (Array.isArray(value)) return true;
	return isPlainObject(value);
}
function createWevuComponent(options) {
	const { properties, props, ...restOptions } = options;
	defineComponent(normalizeProps(restOptions, props, properties));
}
function normalizeProps(baseOptions, props, explicitProperties) {
	if (explicitProperties || !props) return {
		...baseOptions,
		...explicitProperties ? { properties: explicitProperties } : {}
	};
	const properties = {};
	Object.entries(props).forEach(([key, definition]) => {
		if (definition === null || definition === void 0) return;
		if (Array.isArray(definition) || typeof definition === "function") {
			properties[key] = { type: definition };
			return;
		}
		if (typeof definition === "object") {
			if (key.endsWith("Modifiers") && Object.keys(definition).length === 0) {
				properties[key] = {
					type: Object,
					value: {}
				};
				return;
			}
			const propOptions = {};
			if ("type" in definition && definition.type !== void 0) propOptions.type = definition.type;
			const defaultValue = "default" in definition ? definition.default : definition.value;
			if (defaultValue !== void 0) propOptions.value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
			properties[key] = propOptions;
		}
	});
	return {
		...baseOptions,
		properties
	};
}
Object.defineProperty(exports, "createWevuComponent", {
	enumerable: true,
	get: function() {
		return createWevuComponent;
	}
});
Object.defineProperty(exports, "require_other", {
	enumerable: true,
	get: function() {
		return require_other;
	}
});
"
`;

exports[`tabbar-appbar > dist > components/Navbar/Navbar.js 1`] = `
"const require_rolldown_runtime = require("../../rolldown-runtime.js");
Component({ lifetimes: { async attached() {
	const mod = await require.async("../../pages/index/async.js");
	console.log(mod);
} } });
"
`;

exports[`tabbar-appbar > dist > components/Navbar/Navbar.json 1`] = `
"{
  "component": true,
  "styleIsolation": "apply-shared",
  "usingComponents": {}
}"
`;

exports[`tabbar-appbar > dist > components/Navbar/Navbar.wxml 1`] = `
"<view>Navbar</view>
"
`;

exports[`tabbar-appbar > dist > components/Navbar/Navbar.wxss 1`] = `"/*$vite$:1*/"`;

exports[`tabbar-appbar > dist > components/Test/index.js 1`] = `
"const require_rolldown_runtime = require("../../rolldown-runtime.js");
Component({});
"
`;

exports[`tabbar-appbar > dist > components/Test/index.json 1`] = `
"{
  "component": true,
  "styleIsolation": "apply-shared",
  "usingComponents": {}
}"
`;

exports[`tabbar-appbar > dist > components/Test/index.wxml 1`] = `"<view>Navbar</view>"`;

exports[`tabbar-appbar > dist > components/Test/index.wxss 1`] = `
".test {
  clear: both;
}/*$vite$:1*/"
`;

exports[`tabbar-appbar > dist > custom-tab-bar/index.js 1`] = `
"const require_rolldown_runtime = require("../rolldown-runtime.js");
const require_common = require("../common.js");
var a = require_common.require_other();
Component({ lifetimes: { async attached() {
	console.log(a);
	const mod = await require.async("../pages/index/async.js");
	console.log(mod);
} } });
"
`;

exports[`tabbar-appbar > dist > custom-tab-bar/index.json 1`] = `
"{
  "component": true,
  "styleIsolation": "apply-shared",
  "usingComponents": {}
}"
`;

exports[`tabbar-appbar > dist > custom-tab-bar/index.wxml 1`] = `"<view class="pb-8 pt-4 bg-[#af6ec5] flex justify-center">hello weapp-vite! aa</view>"`;

exports[`tabbar-appbar > dist > custom-tab-bar/index.wxss 1`] = `
".a {
  color: red;
}/*$vite$:1*/"
`;

exports[`tabbar-appbar > dist > pages/index/async.js 1`] = `
"const require_rolldown_runtime = require("../../rolldown-runtime.js");
const async = "async";
var async_default = 1;
exports.async = async;
exports.default = async_default;
"
`;

exports[`tabbar-appbar > dist > pages/index/index.js 1`] = `
"const require_rolldown_runtime = require("../../rolldown-runtime.js");
const require_common = require("../../common.js");
var scriptRel = "modulepreload";
var assetsURL = function(dep) {
	return "/" + dep;
};
var seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
	let promise = Promise.resolve();
	if (__VITE_IS_MODERN__ && deps && deps.length > 0) {
		const links = document.getElementsByTagName("link");
		const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
		const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
		function allSettled(promises$2) {
			return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
				status: "fulfilled",
				value: value$1
			}), (reason) => ({
				status: "rejected",
				reason
			}))));
		}
		promise = allSettled(deps.map((dep) => {
			dep = assetsURL(dep, importerUrl);
			if (dep in seen) return;
			seen[dep] = true;
			const isCss = dep.endsWith(".css");
			const cssSelector = isCss ? "[rel=\\"stylesheet\\"]" : "";
			if (!!importerUrl) for (let i = links.length - 1; i >= 0; i--) {
				const link$1 = links[i];
				if (link$1.href === dep && (!isCss || link$1.rel === "stylesheet")) return;
			}
			else if (document.querySelector(\`link[href="\${dep}"]\${cssSelector}\`)) return;
			const link = document.createElement("link");
			link.rel = isCss ? "stylesheet" : scriptRel;
			if (!isCss) link.as = "script";
			link.crossOrigin = "";
			link.href = dep;
			if (cspNonce) link.setAttribute("nonce", cspNonce);
			document.head.appendChild(link);
			if (isCss) return new Promise((res, rej) => {
				link.addEventListener("load", res);
				link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(\`Unable to preload CSS for \${dep}\`)));
			});
		}));
	}
	function handlePreloadError(err$2) {
		const e$1 = new Event("vite:preloadError", { cancelable: true });
		e$1.payload = err$2;
		window.dispatchEvent(e$1);
		if (!e$1.defaultPrevented) throw err$2;
	}
	return promise.then((res) => {
		for (const item of res || []) {
			if (item.status !== "rejected") continue;
			handlePreloadError(item.reason);
		}
		return baseModule().catch(handlePreloadError);
	});
};
var part_exports = /* @__PURE__ */ require_rolldown_runtime.__exportAll({
	default: () => 3,
	part: () => part$1
}, 1);
var part$1, part_default;
var init_part = require_rolldown_runtime.__esmMin((() => {
	part$1 = "part";
}));
var { part } = (init_part(), require_rolldown_runtime.__toCommonJS(part_exports));
var { other } = require_common.require_other();
Page({ async onLoad() {
	const mod = await require.async("./async");
	const mod2 = await __vitePreload(() => Promise.resolve().then(() => require("../../async2.js")), void 0);
	console.log(part, other, mod, mod2);
} });
"
`;

exports[`tabbar-appbar > dist > pages/index/index.json 1`] = `
"{
  "usingComponents": {
    "Navbar": "/components/Navbar/Navbar"
  },
  "navigationBarTitleText": "初始模板"
}"
`;

exports[`tabbar-appbar > dist > pages/index/index.wxml 1`] = `
"<view>
  <Navbar />
  <view>Hello World From Weapp-vite!</view>
</view>
"
`;

exports[`tabbar-appbar > dist > pages/index/index.wxss 1`] = `"/*$vite$:1*/"`;

exports[`tabbar-appbar > dist > pages/index/vue.js 1`] = `
"const require_rolldown_runtime = require("../../rolldown-runtime.js");
const require_common = require("../../common.js");
require_common.createWevuComponent({});
"
`;

exports[`tabbar-appbar > dist > pages/index/vue.json 1`] = `
"{
  "component": true
}"
`;

exports[`tabbar-appbar > dist > pages/index/vue.wxml 1`] = `"<view> 111 </view>"`;

exports[`tabbar-appbar > dist > pages/index/vue.wxss 1`] = `
".a {
  color: red;
}"
`;

exports[`tabbar-appbar > dist > pages/index/vue-setup.js 1`] = `
"const require_rolldown_runtime = require("../../rolldown-runtime.js");
const require_common = require("../../common.js");
require_common.createWevuComponent({});
"
`;

exports[`tabbar-appbar > dist > pages/index/vue-setup.json 1`] = `
"{
  "component": true
}"
`;

exports[`tabbar-appbar > dist > pages/index/vue-setup.wxml 1`] = `"<view> 222 </view>"`;

exports[`tabbar-appbar > dist > pages/index/vue-setup.wxss 1`] = `
".b {
  color: red;
}"
`;

exports[`tabbar-appbar > dist > rolldown-runtime.js 1`] = `
"var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esmMin = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __commonJSMin = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __exportAll = (all, symbols) => {
	let target = {};
	for (var name in all) __defProp(target, name, {
		get: all[name],
		enumerable: true
	});
	if (symbols) __defProp(target, Symbol.toStringTag, { value: "Module" });
	return target;
};
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toCommonJS = (mod) => __hasOwnProp.call(mod, "module.exports") ? mod["module.exports"] : __copyProps(__defProp({}, "__esModule", { value: true }), mod);
Object.defineProperty(exports, "__commonJSMin", {
	enumerable: true,
	get: function() {
		return __commonJSMin;
	}
});
Object.defineProperty(exports, "__esmMin", {
	enumerable: true,
	get: function() {
		return __esmMin;
	}
});
Object.defineProperty(exports, "__exportAll", {
	enumerable: true,
	get: function() {
		return __exportAll;
	}
});
Object.defineProperty(exports, "__toCommonJS", {
	enumerable: true,
	get: function() {
		return __toCommonJS;
	}
});
"
`;

exports[`tabbar-appbar > dist > sitemap.json 1`] = `
"{
  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",
  "rules": [
    {
      "action": "allow",
      "page": "*"
    }
  ]
}"
`;

exports[`tabbar-appbar > dist > theme.json 1`] = `
"{
  "light": {},
  "dark": {}
}"
`;

exports[`tabbar-appbar > dist 1`] = `
[
  "app-bar/index.js",
  "app-bar/index.json",
  "app-bar/index.wxml",
  "app-bar/index.wxss",
  "app.js",
  "app.json",
  "app.wxss",
  "async2.js",
  "common.js",
  "components/Navbar/Navbar.js",
  "components/Navbar/Navbar.json",
  "components/Navbar/Navbar.wxml",
  "components/Navbar/Navbar.wxss",
  "components/Test/index.js",
  "components/Test/index.json",
  "components/Test/index.wxml",
  "components/Test/index.wxss",
  "custom-tab-bar/index.js",
  "custom-tab-bar/index.json",
  "custom-tab-bar/index.wxml",
  "custom-tab-bar/index.wxss",
  "pages/index/async.js",
  "pages/index/index.js",
  "pages/index/index.json",
  "pages/index/index.wxml",
  "pages/index/index.wxss",
  "pages/index/vue-setup.js",
  "pages/index/vue-setup.json",
  "pages/index/vue-setup.wxml",
  "pages/index/vue-setup.wxss",
  "pages/index/vue.js",
  "pages/index/vue.json",
  "pages/index/vue.wxml",
  "pages/index/vue.wxss",
  "rolldown-runtime.js",
  "sitemap.json",
  "theme.json",
]
`;
