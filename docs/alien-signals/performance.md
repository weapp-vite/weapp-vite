# 为什么快（与常见响应系统对照）

概要

- 快的根本不是“更神奇的算法”，而是“让常见模式在 JS 引擎里更容易被优化”：
  - 避免 Proxy 与通用 trap：直接围绕“值槽（signal）”与“函数（computed/effect）”工作；
  - 内存布局可预测：单形对象形状、数组/链表而非动态 Map/Set；
  - 推-拉混合：写入只打脏/入队，读取才按版本判断是否重算；避免全图广播；
  - 小批量、去重、拓扑安全的 scheduler，避免重复与反复递归；
  - 低分配、低 GC 压力：复用依赖边结构，尽量不在热路径分配。

与 Vue 3（Proxy）对比

- Vue 通过 Proxy 捕获任意属性访问，抽象强但每次读/写均走 trap → 额外的形态判断与路径分发；
- alien-signals 以“细粒度值容器”为单位建立依赖，不对任意对象做代理 → 热路径少分支，JIT 更友好；
- Vue 的 scheduler 更通用，包含组件层级/渲染任务；alien-signals 的任务是“值驱动的 effect”，调度面更小。

与 Solid/Preact Signals 对比

- Solid 与 @preact/signals 也极快，核心思想相近（信号 + 版本 + 脏标）；
- alien-signals 的实现更“偏底层”：
  - 更积极的对象形状/字段布局优化；
  - 订阅表尽量用 array/单链表 + 游标，而非 Set；
  - 对 effect/computed 的执行/清理路径更短（少封装层）。

与 RxJS 对比

- Rx 更偏“流”（可多播/背压/错误通道等），抽象成本高于“本地可达的小图”；
- alien-signals 的图是纯同步、无背压/多播概念的轻图，做到了更低的每条边开销。

微基准的获胜点

- 每次 signal.set() 的常数工作更少（无大对象构造、无多层回调/装箱）；
- 每次 computed.value 读取的热路径为“检查版本数组并短路”，命中率高；
- 大量 effect（上千）时，批调度去重 + 避免重复入队，峰值稳定；
- 更低的 GC：长期执行下，堆增长平稳、minor GC 次数少。

真实系统的含义

- 在 UI 框架中，将“视图 diff/渲染”移出响应系统可得更纯净的信号性能（alien-signals 的哲学）；
- 若集成到组件体系，注意保持“细粒度订阅 + 层级缓存 + 控制渲染边界”的组合，才能把信号层的优势放大。
