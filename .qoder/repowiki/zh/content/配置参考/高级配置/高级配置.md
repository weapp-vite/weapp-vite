# 高级配置

<cite>
**本文档引用的文件**
- [vite.config.ts](file://apps/vite-native/vite.config.ts)
- [vite.config.mts](file://apps/plugin-demo/vite.config.mts)
- [vite.config.ts](file://apps/subpackage-shared-chunks/vite.config.ts)
- [alias.md](file://website/guide/alias.md)
- [paths.md](file://website/config/paths.md)
- [shared.md](file://website/config/shared.md)
- [config.ts](file://packages/weapp-vite/src/types/config.ts)
- [tsconfigJson.ts](file://@weapp-core/init/src/tsconfigJson.ts)
</cite>

## 目录
1. [简介](#简介)
2. [别名配置](#别名配置)
3. [路径映射](#路径映射)
4. [共享模块配置](#共享模块配置)
5. [配置项关系与冲突解决](#配置项关系与冲突解决)
6. [最佳实践](#最佳实践)
7. [结论](#结论)

## 简介
`weapp-vite` 提供了强大的高级配置功能，旨在提升小程序开发的效率和代码组织性。本文档深入讲解别名配置、路径映射和共享模块配置三大核心功能，通过具体示例和实际应用场景，帮助开发者充分利用这些特性。这些配置不仅简化了路径引用，还实现了跨分包的代码共享和优化，是构建大型小程序项目的关键。

## 别名配置

`weapp-vite` 同时支持 **JS/TS 别名** 与 **JSON/JSONC 别名**，允许开发者在不同语言中使用一致的路径前缀，极大地提升了代码的可读性和维护性。

### JS/TS 别名
在项目中已默认启用 `vite-tsconfig-paths` 插件，因此只需在 `tsconfig.json` 或 `jsconfig.json` 中配置 `baseUrl` 和 `paths` 即可使用别名。

例如，在 `tsconfig.json` 中配置：
```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  }
}
```
配置完成后，即可在 TypeScript 代码中使用：
```ts
import utils from '@/utils'
```
在执行 `weapp-vite dev` 或 `weapp-vite build` 时，路径会被自动解析为真实文件位置。

**Section sources**
- [tsconfigJson.ts](file://@weapp-core/init/src/tsconfigJson.ts#L29-L73)
- [config.ts](file://packages/weapp-vite/src/types/config.ts#L16-L19)

### JSON/JSONC 别名
`weapp-vite` 对所有 JSON 配置文件进行了增强，支持注释和别名映射，帮助更好地组织大型项目。

要启用 JSON 别名，可在 `vite.config.ts` 中配置 `weapp.jsonAlias.entries`：
```ts
import type { UserConfig } from 'weapp-vite/config'
import path from 'node:path'

export default <UserConfig>{
  weapp: {
    jsonAlias: {
      entries: [
        {
          find: '@',
          replacement: path.resolve(__dirname, 'components'),
        },
      ],
    },
  },
}
```
配置完成后，可以在任何 JSON/JSONC 文件中直接书写别名：
```json
{
  "usingComponents": {
    "navigation-bar": "@/navigation-bar/navigation-bar",
    "ice-avatar": "@/avatar/avatar"
  }
}
```
构建时会自动转换为相对路径：
```json
{
  "usingComponents": {
    "navigation-bar": "../../components/navigation-bar/navigation-bar",
    "ice-avatar": "../../components/avatar/avatar"
  }
}
```

**Section sources**
- [vite.config.ts](file://apps/vite-native/vite.config.ts#L59-L67)
- [alias.md](file://website/guide/alias.md#L90-L135)

## 路径映射

路径映射配置允许开发者自定义项目的基础目录和资源收集方式，使项目结构更贴近团队习惯。

### `weapp.srcRoot`
- **类型**：`string`
- **默认值**：`'.'`
- **适用场景**：当 `app.json` 不在仓库根目录，或希望将源码集中到 `src/`、`packages/miniprogram/` 等目录时使用。

```ts
import { defineConfig } from 'weapp-vite/config'

export default defineConfig({
  weapp: {
    srcRoot: './miniprogram',
  },
})
```
设置后，构建器会从该目录查找 `app.json`、入口 JS/TS、模板与静态资源，并同步更新输出目录结构和文件监听范围。

### `weapp.pluginRoot`
- **类型**：`string`
- **默认值**：`undefined`
- **适用场景**：项目内同时维护小程序插件，需要打包 `plugin.json` 以及插件逻辑。

```ts
export default defineConfig({
  weapp: {
    srcRoot: '.',
    pluginRoot: './plugin',
  },
})
```
启用后，构建器会读取 `plugin.json`，将其中声明的页面与组件纳入扫描，确保插件部分与主包同步输出。

### `weapp.copy`
- **类型**：`{ include?: string[]; exclude?: string[]; filter?: (filePath: string) => boolean }`
- **默认值**：`undefined`
- **适用场景**：需要额外拷贝第三方字体、证书、配置文件等静态资源到输出目录。

```ts
export default defineConfig({
  weapp: {
    copy: {
      include: ['**/*.ttf', '**/*.cer'],
      exclude: ['**/examples/**'],
      filter(filePath) {
        return !filePath.includes('README')
      },
    },
  },
})
```

**Section sources**
- [paths.md](file://website/config/paths.md#L7-L65)
- [vite.config.mts](file://apps/plugin-demo/vite.config.mts#L6-L7)

## 共享模块配置

共享模块配置允许开发者控制跨分包共享代码的输出策略，优化项目结构和性能。

### `weapp.chunks.sharedStrategy`
- **类型**：`'hoist' | 'duplicate'`
- **默认值**：`'duplicate'`
- **描述**：控制跨分包共享代码的输出策略。
  - `duplicate`：默认策略，将共享代码复制到各自的分包中。
  - `hoist`：将共享代码提炼到主包中。

```ts
export default defineConfig({
  weapp: {
    chunks: {
      sharedStrategy: 'duplicate',
    },
  },
})
```

### `weapp.subPackages`
- **类型**：`Record<string, { independent?: boolean, dependencies?: (string | RegExp)[], styles?: SubPackageStyleConfigEntry | SubPackageStyleConfigEntry[] }>`
- **描述**：分包配置，支持独立分包和共享样式。

```ts
export default defineConfig({
  weapp: {
    subPackages: {
      'packages/order': {
        independent: true,
        dependencies: ['crypto-es'],
        styles: [
          'styles/theme.scss',
          {
            source: '../shared/styles/components.scss',
            scope: 'components',
            include: ['components/**'],
          },
        ],
      },
    },
  },
})
```

**Section sources**
- [vite.config.ts](file://apps/subpackage-shared-chunks/vite.config.ts#L32-L58)
- [config.ts](file://packages/weapp-vite/src/types/config.ts#L299-L327)

## 配置项关系与冲突解决

### 配置项关系
- `weapp.jsonAlias.entries` 与 `tsconfig.json` 中的 `paths` 配置相互独立，分别用于 JSON 和 JS/TS 文件的别名解析。
- `weapp.srcRoot` 影响 `weapp.copy` 的匹配范围，`include` 和 `exclude` 基于 `srcRoot` 进行 glob 模式匹配。
- `weapp.chunks.sharedStrategy` 与 `weapp.subPackages` 中的 `independent` 配置协同工作，决定共享代码的处理方式。

### 冲突解决
- **别名未生效**：请确认 `pnpm dev` 已重启，`tsconfig` 修改后需要重新启动进程，Rolldown 才能读取新的 `paths`。
- **JSON 中提示路径不存在**：开发者工具的校验不理解别名是正常现象，编译产物仍会替换为真实路径。若想在 IDE 内消除警告，可借助自定义类型定义或在 `usingComponents` 上方写注释标记。
- **同时使用多个 `tsconfig`**：可以在 `vite.config.ts` 中配置 `weapp.tsconfigPaths.projects` 指定额外的配置文件，让 monorepo 子包共享同一套别名。

**Section sources**
- [alias.md](file://website/guide/alias.md#L146-L150)
- [config.ts](file://packages/weapp-vite/src/types/config.ts#L383-L384)

## 最佳实践

### 别名配置最佳实践
- 统一业务组件、工具方法的导入路径，避免深层级的 `../../`。
- 让 JSON 配置和 TypeScript 源码共享同一套别名，减少路径维护成本。
- 按团队约定快速切换不同的路径前缀（如 `@components/*`、`@shared/*`）。

### 路径映射最佳实践
- 使用 `weapp.srcRoot` 将源码集中管理，便于团队协作。
- 利用 `weapp.copy` 精确控制静态资源的拷贝，避免不必要的文件包含。
- 通过 `weapp.pluginRoot` 管理小程序插件，确保插件逻辑与主包同步。

### 共享模块配置最佳实践
- 根据项目规模选择合适的 `sharedStrategy`，大型项目推荐使用 `hoist` 策略减少冗余。
- 合理配置 `subPackages`，明确分包的独立性和依赖关系。
- 使用 `styles` 配置共享样式，避免样式重复定义。

**Section sources**
- [shared.md](file://website/config/shared.md#L7-L89)
- [vite.config.ts](file://apps/subpackage-shared-chunks/vite.config.ts#L60-L63)

## 结论
`weapp-vite` 的高级配置功能为小程序开发提供了强大的支持。通过合理配置别名、路径映射和共享模块，可以显著提升开发效率和代码组织性。建议开发者根据项目需求，灵活运用这些配置，同时遵循最佳实践，确保项目的可维护性和性能优化。