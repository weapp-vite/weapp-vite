# 子包定义

<cite>
**本文档中引用的文件**  
- [subpackage-shared-chunks/src/app.json](file://apps/subpackage-shared-chunks/src/app.json)
- [subpackage-shared-chunks/vite.config.ts](file://apps/subpackage-shared-chunks/vite.config.ts)
- [vite-native/vite.config.ts](file://apps/vite-native/vite.config.ts)
- [docs/subpackages.md](file://docs/subpackages.md)
- [website/config/subpackages.md](file://website/config/subpackages.md)
- [website/guide/subpackage.md](file://website/guide/subpackage.md)
</cite>

## 目录
1. [引言](#引言)
2. [子包配置结构详解](#子包配置结构详解)
3. [Vite 配置中的子包高级选项](#vite-配置中的子包高级选项)
4. [子包内页面与资源组织](#子包内页面与资源组织)
5. [子包命名最佳实践](#子包命名最佳实践)
6. [不同业务场景下的子包划分策略](#不同业务场景下的子包划分策略)
7. [子包配置对构建输出的影响](#子包配置对构建输出的影响)
8. [调试与分析工具](#调试与分析工具)
9. [常见问题与解决方案](#常见问题与解决方案)
10. [总结](#总结)

## 引言

在微信小程序开发中，合理使用子包（分包）机制能够显著提升首屏加载速度并有效控制主包体积。`weapp-vite` 框架提供了完整的子包支持，允许开发者通过标准的 `app.json` 配置和 `vite.config.ts` 中的高级选项来精细化管理子包。本文将深入讲解 `weapp-vite` 中子包的定义和配置方法。

**Section sources**
- [docs/subpackages.md](file://docs/subpackages.md#L1-L151)

## 子包配置结构详解

子包的配置主要在 `app.json` 文件中通过 `subpackages` 字段进行声明。每个子包对象包含以下关键参数：

- **root**: 子包的根目录路径，相对于项目根目录。
- **pages**: 子包内包含的页面路径列表，相对于 `root` 目录。
- **name**: 子包的可读名称，用于标识和调试。
- **independent**: 布尔值，表示是否为独立分包。
- **plugins**: 子包使用的插件配置。

例如，在 `subpackage-shared-chunks` 示例中，`app.json` 定义了三个子包：订单中心、个人中心和营销活动，分别对应不同的业务模块。

```json
{
  "subpackages": [
    {
      "root": "packages/order",
      "name": "订单中心",
      "pages": ["index", "detail"],
      "independent": true
    },
    {
      "root": "packages/profile",
      "name": "个人中心",
      "pages": ["index", "settings"]
    },
    {
      "root": "packages/marketing",
      "name": "营销活动",
      "pages": ["poster"]
    }
  ]
}
```

此外，`app.json` 还支持 `preloadRule` 配置，用于预下载关键子包，以及 `lazyCodeLoading` 配置，用于启用分包异步化。

**Section sources**
- [subpackage-shared-chunks/src/app.json](file://apps/subpackage-shared-chunks/src/app.json#L6-L40)
- [docs/subpackages.md](file://docs/subpackages.md#L27-L66)

## Vite 配置中的子包高级选项

在 `vite.config.ts` 中，`weapp.subPackages` 提供了更细粒度的子包编译选项。这些选项允许为每个子包配置独立的构建行为，包括依赖裁剪、样式共享和自动导入组件等。

### 配置示例

```ts
export default defineConfig({
  weapp: {
    subPackages: {
      'packages/order': {
        independent: true,
        dependencies: [/^@order\//, 'dayjs'],
        inlineConfig: {
          define: { 'import.meta.env.ORDER_SCOPE': 'true' },
        },
        autoImportComponents: {
          globs: ['packages/order/components/**/*.wxml'],
        },
        styles: [
          'styles/theme.scss',
          {
            source: '../shared/styles/components.scss',
            scope: 'components',
            include: ['components/**'],
          },
        ],
      },
      'packages/profile': {
        styles: {
          source: 'styles/index.scss',
          scope: 'pages',
        },
      },
    },
    chunks: {
      sharedStrategy: 'duplicate',
      duplicateWarningBytes: 256 * 1024,
    },
  },
})
```

### 字段说明

- **independent**: 将子包编译为独立上下文，通常与 `app.json` 中的设置保持一致。
- **dependencies**: 控制该子包打包到 `miniprogram_npm` 的依赖列表，可使用字符串或正则表达式匹配。
- **inlineConfig**: 为该子包追加 Vite/Rolldown 配置，如 `define`、`plugins` 等。
- **autoImportComponents**: 为子包单独配置组件自动导入，避免与主包策略冲突。
- **styles**: 用于生成共享样式文件并自动注入到子包页面或组件中。

**Section sources**
- [subpackage-shared-chunks/vite.config.ts](file://apps/subpackage-shared-chunks/vite.config.ts#L31-L63)
- [website/config/subpackages.md](file://website/config/subpackages.md#L7-L112)

## 子包内页面与资源组织

子包内的页面和资源应按照业务边界进行组织。每个子包的 `root` 目录下通常包含 `pages` 目录存放页面文件，`components` 目录存放自定义组件，以及其他资源文件如样式、工具函数等。

例如，在 `vite-native` 项目中，`packageA` 和 `packageB` 分别包含各自的页面和资源：

```
packageA/
├── pages/
│   ├── shared-demo/
│   │   ├── index.json
│   │   ├── index.ts
│   │   └── index.wxml
│   ├── cat.json.ts
│   ├── cat.scss
│   ├── cat.ts
│   ├── cat.wxml
│   └── ...
├── index.js
├── index.scss
├── tailwind.config.js
└── utils.ts
```

这种组织方式有助于团队协作和权限划分，确保每个子包的职责清晰。

**Section sources**
- [vite-native/packageA](file://apps/vite-native/packageA)
- [vite-native/packageB](file://apps/vite-native/packageB)

## 子包命名最佳实践

子包的命名应遵循以下最佳实践：

1. **语义化命名**: 使用有意义的名称，如 `packages/order`、`packages/profile`，便于理解和维护。
2. **一致性**: 保持命名风格一致，建议使用小写字母和连字符分隔单词。
3. **业务边界**: 按照业务模块或功能域进行划分，确保每个子包的职责单一。
4. **避免冲突**: 确保子包名称在整个项目中唯一，避免命名冲突。

**Section sources**
- [docs/subpackages.md](file://docs/subpackages.md#L20-L25)

## 不同业务场景下的子包划分策略

### 按功能模块划分

将不同的功能模块拆分为独立的子包，如订单管理、用户中心、营销活动等。这种方式适用于功能相对独立且访问频率不同的模块。

### 按业务域划分

根据业务领域进行划分，如电商、社交、内容等。每个业务域可以作为一个独立的子包，便于团队分工和迭代。

### 按用户角色划分

针对不同用户角色（如普通用户、管理员、商家）设计不同的子包。这种方式适用于多角色系统的复杂业务逻辑。

### 组合策略

结合多种划分策略，如主包 + 独立支付包 + 通用业务包。主包保留登录和首页，支付等高敏感业务单独作为独立分包，其余模块按功能拆分为普通分包。

**Section sources**
- [docs/subpackages.md](file://docs/subpackages.md#L144-L149)

## 子包配置对构建输出的影响

子包配置直接影响构建输出的目录结构和文件命名。`weapp-vite` 根据 `app.json` 和 `vite.config.ts` 的配置生成相应的产物。

### 构建策略

- **duplicate 策略**: 默认策略，跨子包共享的模块会被复制到各个子包的 `__shared__/common.js` 中，避免分包首次打开时回主包拉取。
- **hoist 策略**: 将共享模块统一提炼到主包的 `common.js` 中，适用于更关注整体包体控制的场景。

### 产物位置

- 共享模块：根据 `sharedStrategy` 策略决定落盘位置。
- 第三方依赖：根据 `dependencies` 配置精确控制每个子包的依赖。
- 样式文件：通过 `styles` 配置自动生成并注入到子包页面或组件中。

**Section sources**
- [website/guide/subpackage.md](file://website/guide/subpackage.md#L28-L150)

## 调试与分析工具

`weapp-vite` 提供了强大的调试和分析工具，帮助开发者优化子包配置。

### 分析报告

通过添加 `analyze` 脚本，可以生成详细的分包报告：

```json
{
  "scripts": {
    "analyze": "weapp-vite analyze"
  }
}
```

执行 `pnpm run analyze` 可查看每个子包的产物结构、共享模块和依赖关系。

### 构建日志

关注构建日志中的 `[subpackages]` 警告，它们通常提示路径超出 `srcRoot`、格式不受支持或重复注册等问题。

### 微信开发者工具

使用微信开发者工具的包体积面板，确保主包小于 2MB，单个分包小于 2MB，所有分包合计小于 20MB。

**Section sources**
- [docs/subpackages.md](file://docs/subpackages.md#L137-L143)
- [website/guide/subpackage.md](file://website/guide/subpackage.md#L207-L238)

## 常见问题与解决方案

### 如何保证子包首屏体积最小？

- 确认 `dependencies` 是否精确，排除无用依赖。
- 结合 `chunks.sharedStrategy` 控制跨包共享代码策略。

### 独立分包能使用主包的 autoImport 配置吗？

可以，在 `subPackages.<name>.autoImportComponents` 中复用主包 resolver 或 globs，构建器会自动隔离产物。

### 分包样式冲突怎么办？

- 为不同子包提供独立的样式入口。
- 使用 `include` / `exclude` 精细控制注入范围。

**Section sources**
- [website/config/subpackages.md](file://website/config/subpackages.md#L104-L108)

## 总结

合理规划子包并结合 `weapp-vite` 的构建能力，可以在保证首屏体验的同时降低维护成本。通过 `app.json` 和 `vite.config.ts` 的协同配置，开发者可以实现精细化的子包管理。遇到复杂场景时，优先使用 CLI 分析产物，再针对性调整配置。

**Section sources**
- [docs/subpackages.md](file://docs/subpackages.md#L149-L151)