# 预下载分包

<cite>
**本文档中引用的文件**  
- [subpackage-shared-chunks/src/app.json](file://apps/subpackage-shared-chunks/src/app.json)
- [subpackage-shared-chunks/src/pages/index/index.ts](file://apps/subpackage-shared-chunks/src/pages/index/index.ts)
- [subpackage-shared-chunks/vite.config.ts](file://apps/subpackage-shared-chunks/vite.config.ts)
- [docs/subpackages.md](file://docs/subpackages.md)
- [website/guide/subpackage.md](file://website/guide/subpackage.md)
- [@weapp-core/schematics/src/type.auto.ts](file://@weapp-core/schematics/src/type.auto.ts)
</cite>

## 目录

1. [引言](#引言)
2. [预下载分包工作原理](#预下载分包工作原理)
3. [配置方法与使用场景](#配置方法与使用场景)
4. [构建流程与运行时行为](#构建流程与运行时行为)
5. [性能特点与优化建议](#性能特点与优化建议)
6. [常见问题与解决方案](#常见问题与解决方案)
7. [结论](#结论)

## 引言

预下载分包是微信小程序中提升用户体验的重要机制，通过在特定时机提前加载用户可能访问的分包资源，显著缩短页面跳转时的等待时间。`weapp-vite` 框架对预下载分包提供了完整的支持，开发者可以通过 `app.json` 中的 `preloadRule` 配置或运行时调用 `wx.preloadSubpackage` API 实现精细化控制。本文将深入讲解预下载分包的工作原理、配置方法、构建流程、运行时行为及性能优化策略，为开发者提供全面的实践指导。

## 预下载分包工作原理

预下载分包的核心机制是利用小程序的 `preloadRule` 配置或 `wx.preloadSubpackage` API，在用户尚未跳转到目标分包页面时，提前将其资源从服务器拉取到本地缓存。当用户实际发起跳转时，小程序可以直接从本地加载，从而实现“秒开”效果。

### 触发条件

预下载的触发条件由 `preloadRule` 的键名决定，它必须是一个已存在的页面路径。当用户进入该页面时，预下载任务即被触发。例如，在 `apps/subpackage-shared-chunks/src/app.json` 中配置：
```json
"preloadRule": {
  "pages/index/index": {
    "packages": ["packages/profile"],
    "network": "all",
    "timeout": 2000
  }
}
```
此配置表示：当用户进入 `pages/index/index` 页面时，立即开始预下载 `packages/profile` 分包。

### 网络优化机制

`preloadRule` 支持通过 `network` 字段精细控制预下载的网络策略：
- `"wifi"`：仅在 Wi-Fi 网络下预下载。
- `"all"`：在 Wi-Fi 和蜂窝网络下均进行预下载。

此机制允许开发者在用户体验和流量消耗之间取得平衡。对于体积较大或非关键的分包，可设置为仅在 Wi-Fi 下预下载；而对于高频访问的关键分包，则可设置为 `all`，确保在任何网络环境下都能获得最佳体验。

## 配置方法与使用场景

### 通过 `preloadRule` 配置预下载

`preloadRule` 是在 `app.json` 中声明的静态配置，适用于在页面加载时即确定需要预下载的场景。

**配置项说明：**
- `packages`：字符串数组，指定需要预下载的分包根目录。
- `network`：网络策略，可选 `"wifi"` 或 `"all"`。
- `timeout`：超时时间（毫秒），超过此时间后停止预下载。

**示例：**
```json
"preloadRule": {
  "pages/index/index": {
    "packages": ["packages/profile", "packages/order"],
    "network": "all",
    "timeout": 3000
  }
}
```

**Section sources**
- [apps/subpackage-shared-chunks/src/app.json](file://apps/subpackage-shared-chunks/src/app.json#L24-L30)

### 通过 `wx.preloadSubpackage` 运行时控制

`wx.preloadSubpackage` 是一个运行时 API，提供了更灵活的控制能力，适用于需要根据用户行为、设备状态或业务逻辑动态决定是否预下载的场景。

**API 参数：**
- `name`：分包的根目录。
- `success`：预下载成功的回调函数。
- `fail`：预下载失败的回调函数。
- `complete`：无论成功或失败都会执行的回调函数。
- `network`：可选，覆盖 `app.json` 中的网络策略。

**示例代码：**
```typescript
Page({
  onLoad() {
    // 预下载个人中心分包，并监听成功回调
    wx.preloadSubpackage({
      name: 'packages/profile',
      success() {
        console.log('[index] preload profile success')
      },
    })
    // 预下载订单中心分包，强制在所有网络下进行
    wx.preloadSubpackage({
      name: 'packages/order',
      network: 'all',
    })
  }
})
```

**Section sources**
- [apps/subpackage-shared-chunks/src/pages/index/index.ts](file://apps/subpackage-shared-chunks/src/pages/index/index.ts#L25-L36)

### 使用场景

1.  **首页预加载次屏页面**：在小程序首页加载后，立即预下载用户最可能点击的“个人中心”、“订单中心”等页面，极大提升核心链路的流畅度。
2.  **运营活动预热**：在大型促销活动开始前，通过服务端推送或用户行为预测，提前预下载活动页面分包，确保活动开始时用户能瞬间进入。
3.  **条件性预加载**：结合用户身份、设备性能、网络状况等信息，智能决策是否进行预下载。例如，仅对 VIP 用户或高性能设备预加载高清资源分包。

## 构建流程与运行时行为

### 构建流程

`weapp-vite` 的构建流程会严格遵循 `app.json` 中定义的分包结构。当检测到 `subpackages` 配置时，构建器会：
1.  **解析分包结构**：读取 `app.json`，识别所有分包的 `root` 路径和 `independent` 属性。
2.  **独立编译**：为每个分包（尤其是独立分包）创建独立的编译上下文，确保其依赖（如 `miniprogram_npm`）被正确处理。
3.  **处理共享资源**：根据 `weapp.chunks.sharedStrategy` 策略（`duplicate` 或 `hoist`），决定跨分包共享的代码和资源的最终落盘位置。
4.  **注入预下载配置**：将 `app.json` 中的 `preloadRule` 配置原样输出到构建产物中，供小程序运行时使用。

**Section sources**
- [apps/subpackage-shared-chunks/vite.config.ts](file://apps/subpackage-shared-chunks/vite.config.ts#L4-L65)
- [docs/subpackages.md](file://docs/subpackages.md)

### 运行时行为

1.  **静态预下载**：当用户进入 `preloadRule` 指定的触发页时，小程序客户端会立即根据配置发起预下载请求。下载过程在后台进行，不影响当前页面的渲染。
2.  **动态预下载**：当页面调用 `wx.preloadSubpackage` 时，API 会立即启动下载任务。开发者可以通过回调函数监控下载状态，进行日志记录或错误处理。
3.  **缓存与复用**：成功预下载的分包会被缓存。当用户通过 `wx.navigateTo` 等 API 跳转到该分包内的页面时，小程序会优先使用本地缓存，实现快速加载。
4.  **失败处理**：如果预下载因网络中断等原因失败，当用户跳转时，小程序会回退到正常的按需加载流程，确保功能可用性。

## 性能特点与优化建议

### 性能特点

- **优点**：显著降低目标分包的首次加载时间，提升用户体验。
- **代价**：增加触发页的网络请求和带宽消耗，可能影响触发页自身的加载性能。

### 高级性能调优建议

1.  **预下载时机选择**：
    *   **避免在首屏关键路径上预下载**：在首页 `onLoad` 时发起多个预下载请求，可能会与首屏资源竞争带宽。建议在首页 `onReady` 或用户产生交互（如滚动）后，再启动预下载。
    *   **利用空闲时间**：在用户浏览长列表或观看视频等场景下，利用网络空闲时段进行预下载。

2.  **带宽消耗控制**：
    *   **合理设置 `network` 策略**：对于非核心分包，优先使用 `"wifi"` 策略，避免消耗用户宝贵的蜂窝数据。
    *   **监控 `timeout`**：设置合理的超时时间，避免长时间占用网络连接。`weapp-vite` 的构建报告 (`pnpm run analyze`) 可帮助评估分包大小，为设置 `timeout` 提供依据。

3.  **用户体验优化**：
    *   **结合加载提示**：对于体积较大的分包，可以在用户跳转前显示加载动画，管理用户预期。
    *   **降级策略**：始终确保即使预下载失败，用户也能通过正常流程访问页面。

**Section sources**
- [docs/subpackages.md](file://docs/subpackages.md)
- [website/guide/subpackage.md](file://website/guide/subpackage.md)

## 常见问题与解决方案

1.  **问题：预下载没有生效**
    *   **解决方案**：检查 `app.json` 中 `preloadRule` 的触发页路径是否正确且存在。确认目标分包的 `root` 路径与配置完全一致。检查网络状况和 `network` 配置是否匹配。

2.  **问题：预下载消耗过多流量**
    *   **解决方案**：将 `network` 策略从 `"all"` 修改为 `"wifi"`。评估预下载的必要性，避免预下载低频使用的分包。

3.  **问题：独立分包无法访问主包资源**
    *   **解决方案**：这是独立分包的设计限制。公共逻辑和资源应上移到主包或通过 `weapp.subPackages[].styles` 注入共享样式。避免在独立分包中引用主包的 JS、WXML 或 WXSS 文件。

4.  **问题：构建时报错“无法找到分包”**
    *   **解决方案**：检查 `vite.config.ts` 中 `weapp.subPackages` 的配置是否与 `app.json` 一致。确保分包目录在 `srcRoot` 范围内。

**Section sources**
- [website/guide/subpackage.md](file://website/guide/subpackage.md)

## 结论

预下载分包是优化小程序性能的关键技术。通过 `weapp-vite` 框架，开发者可以轻松地通过 `preloadRule` 静态配置或 `wx.preloadSubpackage` 动态 API 实现分包的预下载。理解其工作原理、合理选择配置方法、并根据实际场景进行性能调优，能够有效提升小程序的用户体验。在使用时，应权衡预下载带来的性能收益与额外的网络开销，制定最优的预下载策略。